/**
 * @author tsarag
 */

// === VARIABLES PRINCIPALES ===
let img;
let particles = [];
let validPixels = [];
let hotZones = [];
const NUM_PARTICLES = 500;
let canvasContainer;

// Syst√®me de vagues de flou
let nextBlurWave = 0;

// Variables audio simplifi√©es mais fonctionnelles
let audioEnabled = false;
let audioContext;
let gainNode;

// üöÄ OPTIMISATION DOM : Throttling des mises √† jour de stats
let lastStatsUpdate = 0;
const STATS_UPDATE_INTERVAL = 16; // Mise √† jour toutes les 16 frames (~0.5s √† 30 FPS)

// üöÄ OPTIMISATION PHASE 1 : Variables de cache pour performance
let imgOffsetX = 0,
  imgOffsetY = 0; // Translation calcul√©e une fois
let validPixelsCount = 0,
  hotZonesCount = 0; // Longueurs cach√©es
let particlesCount = 0; // Cache particles.length
let mouseWorldX = 0,
  mouseWorldY = 0; // Position souris dans le monde
let reusableMousePixel = { x: 0, y: 0 }; // Objet r√©utilisable
let depthSortNeeded = false; // Flag tri conditionnel

// Pool de s√©lections al√©atoires pr√©-calcul√©es
let randomPixelPool = [];
let randomParticlePool = [];
let poolIndex = 0;
const POOL_SIZE = 20;

const colorPalette = [
  [255, 255, 255], // White
  [0, 180, 255], // Electric Blue
  [0, 255, 255], // Cyan
  [150, 220, 255], // Light Blue
];

// üöÄ FONCTIONS UTILITAIRES OPTIMIS√âES
function updatePerformanceCache() {
  // Mise √† jour une fois par frame des calculs co√ªteux
  imgOffsetX = (width - img.width) / 2;
  imgOffsetY = (height - img.height) / 2;
  validPixelsCount = validPixels.length;
  hotZonesCount = hotZones.length;
  particlesCount = particles.length;
  mouseWorldX = mouseX - imgOffsetX;
  mouseWorldY = mouseY - imgOffsetY;

  // Mise √† jour objet r√©utilisable
  reusableMousePixel.x = mouseWorldX;
  reusableMousePixel.y = mouseWorldY;
}

function generateRandomPools() {
  // G√©n√©rer pools de s√©lections al√©atoires pr√©-calcul√©es
  randomPixelPool = [];
  randomParticlePool = [];

  for (let i = 0; i < POOL_SIZE; i++) {
    if (validPixelsCount > 0) {
      randomPixelPool[i] = Math.floor(Math.random() * validPixelsCount);
    }
    if (particlesCount > 0) {
      randomParticlePool[i] = Math.floor(Math.random() * particlesCount);
    }
  }
  poolIndex = 0;
}

function getRandomPixel() {
  // S√©lection optimis√©e depuis le pool pr√©-calcul√©
  if (randomPixelPool.length === 0 || validPixelsCount === 0) return null;

  if (poolIndex >= randomPixelPool.length) {
    generateRandomPools(); // R√©g√©n√©rer si n√©cessaire
  }

  const index = randomPixelPool[poolIndex++];
  return validPixels[index] || null;
}

function getRandomParticle() {
  // S√©lection optimis√©e depuis le pool pr√©-calcul√©
  if (randomParticlePool.length === 0 || particlesCount === 0) return null;

  if (poolIndex >= randomParticlePool.length) {
    generateRandomPools(); // R√©g√©n√©rer si n√©cessaire
  }

  const index = randomParticlePool[poolIndex++];
  return particles[index] || null;
}

// === FONCTIONS CORE ===
function preload() {
  img = loadImage("https://iili.io/FTkLiuV.webp");
}

function setup() {
  canvasContainer = select("#canvas-container");
  let cnv = createCanvas(canvasContainer.width, canvasContainer.height);
  cnv.parent("canvas-container");

  img.resize(img.width * 2, 0); // Scale up the image

  // √âchantillonnage des pixels valides
  img.loadPixels();
  const sampleSize = NUM_PARTICLES * 3;

  for (let i = 0; i < sampleSize; i++) {
    let x = floor(random(img.width));
    let y = floor(random(img.height));
    let index = (x + y * img.width) * 4;
    let a = img.pixels[index + 3];

    if (a > 128) {
      validPixels.push({ x: x, y: y });
    }
  }

  // Fallback si pas assez de pixels
  if (validPixels.length < NUM_PARTICLES) {
    validPixels = [];
    for (let i = 0; i < NUM_PARTICLES * 2; i++) {
      validPixels.push({
        x: random(img.width),
        y: random(img.height),
      });
    }
  }

  // Cr√©er les particules initiales
  for (let i = 0; i < NUM_PARTICLES; i++) {
    let randomPixel = random(validPixels);
    if (randomPixel) {
      particles.push(new Particle(randomPixel.x, randomPixel.y));
    }
  }

  // üöÄ OPTIMISATION FRAME RATE : Limiter √† 30 FPS pour r√©duire la charge CPU
  frameRate(30);

  // üöÄ INITIALISATION DU CACHE DE PERFORMANCE
  updatePerformanceCache();
  generateRandomPools();

  // Initialiser l'audio simplifi√©
  initAudio();
}

function draw() {
  // üöÄ MISE √Ä JOUR DU CACHE DE PERFORMANCE (une fois par frame)
  updatePerformanceCache();

  background("#0a0a0a");
  translate(imgOffsetX, imgOffsetY); // Utilise le cache au lieu de recalculer

  // Cr√©ation automatique de zones d'activit√© (utilise cache)
  if (frameCount % 45 === 0 && validPixelsCount > 0 && hotZonesCount < 8) {
    const randomPixel = getRandomPixel(); // Utilise pool optimis√©
    if (randomPixel) {
      hotZones.push(new SimpleHotZone(randomPixel.x, randomPixel.y));
      hotZonesCount++; // Mise √† jour cache locale
    }
  }

  // Zones al√©atoires suppl√©mentaires (utilise cache)
  if (random() < 0.008 && validPixelsCount > 0 && hotZonesCount < 8) {
    const randomPixel = getRandomPixel(); // Utilise pool optimis√©
    if (randomPixel) {
      hotZones.push(new SimpleHotZone(randomPixel.x, randomPixel.y));
      hotZonesCount++; // Mise √† jour cache locale
    }
  }

  // D√©tection zones souris (utilise objet r√©utilisable)
  if (mouseIsPressed && validPixelsCount > 0 && hotZonesCount < 8) {
    if (
      reusableMousePixel.x >= 0 &&
      reusableMousePixel.x < img.width &&
      reusableMousePixel.y >= 0 &&
      reusableMousePixel.y < img.height
    ) {
      hotZones.push(
        new SimpleHotZone(reusableMousePixel.x, reusableMousePixel.y)
      );
      hotZonesCount++; // Mise √† jour cache locale
    }
  }

  // Mise √† jour des zones (avec cache local)
  for (let i = hotZonesCount - 1; i >= 0; i--) {
    hotZones[i].update();
    if (hotZones[i].isDead()) {
      hotZones.splice(i, 1);
      hotZonesCount--; // Mise √† jour cache locale
    }
  }

  // Limite des zones (avec cache)
  if (hotZonesCount > 8) {
    const toRemove = hotZonesCount - 8;
    hotZones.splice(0, toRemove);
    hotZonesCount = 8; // Mise √† jour cache
  }

  // Vagues de flou automatiques
  if (frameCount > nextBlurWave) {
    nextBlurWave = frameCount + random(180, 360);
    triggerBlurWave();
  }

  // Effets shimmer R√âDUITS √∑3 (utilise pool optimis√©)
  if (random(1) < 0.083) {
    // R√©duit de 0.25 √† 0.083 (√∑3)
    let p = getRandomParticle(); // Pool optimis√©
    if (p) p.shine();
  }

  // Shimmer en cascade R√âDUIT √∑3 (utilise pool optimis√©)
  if (random(1) < 0.017) {
    // R√©duit de 0.05 √† 0.017 (√∑3)
    for (let i = 0; i < 3; i++) {
      // R√©duit de 5 √† 3 particules en cascade
      let p = getRandomParticle(); // Pool optimis√©
      if (p) {
        // TODO: Remplacer setTimeout par syst√®me unifi√©
        setTimeout(() => p.shine(), i * 50);
      }
    }
  }

  // üöÄ TRI CONDITIONNEL : Seulement si nouvelles particules ajout√©es
  if (depthSortNeeded) {
    particles.sort((a, b) => a.depth - b.depth);
    depthSortNeeded = false;
  }

  // R√©g√©n√©rer pools p√©riodiquement pour maintenir la randomisation
  if (frameCount % 120 === 0) {
    generateRandomPools();
  }

  for (let p of particles) {
    p.update();
    p.show();
  }

  let activityLevel = connectParticles();
  updateAudio(activityLevel);
  displayInfo();
}

// === SYST√àME DE CONNEXIONS ULTRA-OPTIMIS√â ===
function connectParticles() {
  const threshold = 50;
  const thresholdSquared = threshold * threshold; // üöÄ √âviter sqrt dans la boucle
  let activityLevel = 0;
  const maxConnections = min(particlesCount * 6, 1500); // üöÄ R√©duction l√©g√®re des connexions
  let connectionCount = 0;

  // üöÄ OPTIMISATION MAJEURE : Regrouper les lignes par style pour √©viter stroke() r√©p√©t√©s
  const normalConnections = [];
  const activeConnections = [];
  const electricConnections = [];

  for (let i = 0; i < particlesCount && connectionCount < maxConnections; i++) {
    let particleConnections = 0;
    const maxPerParticle = 6; // üöÄ R√©duction de 8 √† 6 connexions max par particule

    for (
      let j = i + 1;
      j < particlesCount && particleConnections < maxPerParticle;
      j++
    ) {
      const p1 = particles[i];
      const p2 = particles[j];

      // üöÄ OPTIMISATION : Comparaison distance au carr√© (√©vite sqrt)
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      const distSquared = dx * dx + dy * dy;

      if (distSquared > 0 && distSquared < thresholdSquared) {
        const d = Math.sqrt(distSquared); // Calculer sqrt seulement si n√©cessaire
        let maxAlpha = 60;

        const inZone = isParticleActive(p1) || isParticleActive(p2);
        if (inZone) {
          maxAlpha = 220;
          activityLevel++;
        }

        const avgDepth = (p1.depth + p2.depth) / 2;
        const depthAlphaModifier = map(avgDepth, 0, 1, 0.4, 1.2);
        const alpha = map(d, 0, threshold, maxAlpha * depthAlphaModifier, 0);
        const strokeWidth = map(avgDepth, 0, 1, 0.4, 1.8);

        // üöÄ OPTIMISATION : Regrouper par type de connexion au lieu de dessiner imm√©diatement
        const connectionData = { p1, p2, alpha, strokeWidth };

        if (inZone && random(1) < 0.4) {
          // Connexions √©lectriques actives
          electricConnections.push(connectionData);
        } else if (inZone) {
          // Connexions actives normales
          activeConnections.push(connectionData);
        } else {
          // Connexions normales
          normalConnections.push(connectionData);
        }

        particleConnections++;
        connectionCount++;
      }
    }
  }

  // üöÄ DESKTOP : Toutes les connexions en bleu √©lectrique (identique mobile)
  drawConnectionGroup(normalConnections, [0, 150, 255], 1.0); // Bleu √©lectrique
  drawConnectionGroup(activeConnections, [0, 150, 255], 1.2); // Bleu √©lectrique plus intense
  drawConnectionGroup(electricConnections, [0, 150, 255], 1.5); // Bleu √©lectrique tr√®s intense

  return activityLevel;
}

// üöÄ FONCTION OPTIMIS√âE : Dessiner un groupe de connexions avec le m√™me style
function drawConnectionGroup(connections, baseColor, intensityMultiplier) {
  if (connections.length === 0) return;

  for (const conn of connections) {
    const finalAlpha = min(conn.alpha * intensityMultiplier, 255);
    stroke(baseColor[0], baseColor[1], baseColor[2], finalAlpha);
    strokeWeight(conn.strokeWidth * intensityMultiplier);
    line(conn.p1.x, conn.p1.y, conn.p2.x, conn.p2.y);
  }
}

// üöÄ FONCTION OPTIMIS√âE : Utilise les variables de cache
function isParticleActive(particle) {
  // Utilise les coordonn√©es pr√©-calcul√©es au lieu de recalculer
  const mouseDistance = dist(particle.x, particle.y, mouseWorldX, mouseWorldY);

  if (mouseDistance < 70) return true; // R√©duit de 100 √† 70 pour coh√©rence avec la r√©pulsion

  // Optimisation: utilise cache de longueur pour √©viter .length √† chaque it√©ration
  for (let i = 0; i < hotZonesCount; i++) {
    const zone = hotZones[i];
    if (dist(particle.x, particle.y, zone.x, zone.y) < zone.radius) {
      return true;
    }
  }

  return false;
}

// === AFFICHAGE INFO OPTIMIS√â ===
function displayInfo() {
  // üöÄ OPTIMISATION DOM : Throttling des mises √† jour de stats pour √©viter 60 redraws/s
  if (frameCount - lastStatsUpdate >= STATS_UPDATE_INTERVAL) {
    const statsElement = document.getElementById("dynamic-stats");

    if (statsElement) {
      const zones = hotZones.length;

      let statsHTML = `${particles.length} neurons active`;
      statsHTML += `<br>Connections firing`;
      statsHTML += `<br>üîµ ${zones}/8 zones (blue)`;
      statsHTML += `<br><span style="color: #0096ff; font-size: 0.8em;">‚ö° Brain V2 - Blue Electric</span>`;

      statsElement.innerHTML = statsHTML;
    }
    lastStatsUpdate = frameCount;
  }

  // Audio toggle (simplifi√©)
  resetMatrix();
  const buttonX = width - 50;
  const buttonY = 40;

  noStroke();
  fill(0, 0, 0, 100);
  ellipse(buttonX, buttonY, 35, 35);

  stroke(100, 100, 100, 150);
  strokeWeight(1);
  noFill();
  ellipse(buttonX, buttonY, 35, 35);

  noStroke();
  textAlign(CENTER, CENTER);
  textSize(18);

  if (audioEnabled) {
    fill(200, 200, 200, 255);
    text("‚ô™", buttonX, buttonY - 2);
  } else {
    fill(120, 120, 120, 200);
    text("‚ô™", buttonX, buttonY - 2);
    stroke(120, 120, 120, 200);
    strokeWeight(2);
    line(buttonX - 10, buttonY - 10, buttonX + 10, buttonY + 10);
  }

  // Contr√¥les
  if (mouseX < 150 && mouseY > height - 70) {
    fill(0, 0, 0, 40);
    noStroke();
    rect(10, height - 65, 140, 55);

    textAlign(LEFT);
    textSize(8);
    fill(120, 120, 140, 120);
    text("+ : Add neurons", 15, height - 50);
    text("- : Remove neurons", 15, height - 40);
    text("R : Reset ‚Ä¢ C : Clear", 15, height - 30);
    text("üé® B : Blur Wave", 15, height - 20);
  }
}

// === CLASSES ===
class SimpleHotZone {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.maxRadius = random(80, 140);
    this.speed = random(1.5, 3);
    this.life = 240;
  }

  update() {
    this.radius += this.speed;
    this.life--;
  }

  isDead() {
    return this.life <= 0 || this.radius > this.maxRadius;
  }
}

class Particle {
  constructor(x, y) {
    this.targetX = x;
    this.targetY = y;
    this.x = this.targetX + random(-2, 2);
    this.y = this.targetY + random(-2, 2);
    this.vx = 0;
    this.vy = 0;

    // Distribution √©quilibr√©e des profondeurs
    const depthRandom = random();
    if (depthRandom < 0.3) {
      this.depth = random(0.7, 1); // 30% grandes
    } else if (depthRandom < 0.6) {
      this.depth = random(0.4, 0.7); // 30% moyennes
    } else {
      this.depth = random(0, 0.4); // 40% petites
    }

    const grayValue = map(this.depth, 0, 1, 200, 60);
    const alpha = map(this.depth, 0, 1, 120, 220);
    this.color = color(grayValue, grayValue, grayValue, alpha);
    this.baseSize = map(this.depth, 0, 1, 2.5, 7);

    this.noiseOffsetX = random(1000);
    this.noiseOffsetY = random(1000);
    this.shimmer = 0;

    // Syst√®me de flou
    this.blurPhase = random(TWO_PI);
    this.blurSpeed = random(0.01, 0.05);
    this.maxBlur = random(5, 25);
    this.blurIntensity = 0;
  }

  update() {
    // üöÄ R√âPULSION SOURIS ULTRA-OPTIMIS√âE : Effet plus subtil et agr√©able
    const dx = this.x - mouseWorldX;
    const dy = this.y - mouseWorldY;
    const distSquared = dx * dx + dy * dy;

    if (distSquared < 1600) {
      // 40*40, zone d'influence r√©duite de 50 √† 40px
      const d = Math.sqrt(distSquared);
      const force = 12 / d; // Force r√©duite de 50 √† 12 pour un effet plus doux
      this.x += dx * force * 0.4; // Facteur d'att√©nuation suppl√©mentaire
      this.y += dy * force * 0.4;
    }

    // üöÄ Mouvement Perlin noise adapt√© pour 30 FPS - R√âDUIT √∑2 pour plus de calme
    const noiseSpeed = 0.0075; // R√©duit de 0.015 √† 0.0075 (√∑2)
    const noiseMagnitude = 0.075; // R√©duit de 0.15 √† 0.075 (√∑2)
    let noiseX = noise(this.noiseOffsetX + frameCount * noiseSpeed);
    let noiseY = noise(this.noiseOffsetY + frameCount * noiseSpeed);
    this.vx += map(noiseX, 0, 1, -noiseMagnitude, noiseMagnitude);
    this.vy += map(noiseY, 0, 1, -noiseMagnitude, noiseMagnitude);

    // üöÄ Force de retour adapt√©e pour 30 FPS - R√âDUITE √∑2
    this.vx += (this.targetX - this.x) * 0.004; // R√©duit de 0.008 √† 0.004 (√∑2)
    this.vy += (this.targetY - this.y) * 0.004;

    // üöÄ Amortissement adapt√© pour 30 FPS
    this.vx *= 0.96; // R√©duit de 0.98 √† 0.96 pour plus de fluidit√©
    this.vy *= 0.96;

    this.x += this.vx;
    this.y += this.vy;

    // Fade shimmer - Plus lent pour compenser la r√©duction d'intensit√©
    this.shimmer *= 0.92; // Chang√© de 0.88 √† 0.92 pour durer plus longtemps

    // üöÄ Flou dynamique adapt√© pour 30 FPS
    this.blurPhase += this.blurSpeed;
    this.blurIntensity = (sin(this.blurPhase) + 1) / 2;

    if (random() < 0.025) {
      // Augment√© de 0.015 √† 0.025 pour compenser 30 FPS
      this.blurSpeed = random(0.03, 0.12); // Augment√© pour compenser le framerate
      this.maxBlur = random(12, 30); // R√©duit la valeur max pour √©conomiser des performances
    }
  }

  shine() {
    this.shimmer = 1.2;
  }

  show() {
    noStroke();

    const shimmerColor = color(255, 255, 255, 255);
    let finalColor = lerpColor(this.color, shimmerColor, this.shimmer / 3); // Intensit√© √∑3
    let size = this.baseSize + (this.shimmer / 2) * (this.baseSize * 2); // Taille shimmer √∑3

    // üöÄ OPTIMISATION FLOU : Seulement pour les cas importants
    const needsBlur =
      this.shimmer > 0.1 || this.depth > 0.7 || this.blurIntensity > 0.8;

    if (needsBlur) {
      // Syst√®me de flou limit√© aux cas n√©cessaires
      const depthBlur = this.depth > 0.7 ? map(this.depth, 0.7, 1, 0, 5) : 0; // R√©duction du flou de profondeur
      const shimmerGlow = (this.shimmer / 3) * 20; // Intensit√© shimmer √∑3
      const dynamicBlur =
        this.blurIntensity > 0.8 ? this.blurIntensity * this.maxBlur * 0.6 : 0; // Seuil plus haut et r√©duction
      const totalBlur = depthBlur + shimmerGlow + dynamicBlur;

      drawingContext.shadowBlur = Math.min(totalBlur, 25); // üöÄ Plafond √† 25px au lieu de illimit√©

      if (this.shimmer > 0.1) {
        drawingContext.shadowColor = `rgba(255, 255, 255, ${
          (this.shimmer / 3) * 0.4
        })`; // Intensit√© √∑3
      } else if (this.blurIntensity > 0.8) {
        const haloIntensity = this.blurIntensity * 0.2; // R√©duction de l'intensit√©
        drawingContext.shadowColor = `rgba(150, 220, 255, ${haloIntensity})`; // Couleur fixe au lieu de random
      } else {
        const shadowIntensity = map(this.depth, 0.7, 1, 0.1, 0.2);
        drawingContext.shadowColor = `rgba(200, 200, 200, ${shadowIntensity})`;
      }
    } else {
      // üöÄ Pas de flou pour les particules normales = gain de performance majeur
      drawingContext.shadowBlur = 0;
    }

    fill(finalColor);
    ellipse(this.x, this.y, size, size);

    if (needsBlur) {
      drawingContext.shadowBlur = 0; // Reset seulement si on avait du flou
    }
  }
}

// === FONCTIONS INTERACTIVES ===
function triggerBlurWave() {
  const waveCenter = getRandomPixel(); // üöÄ Pool optimis√©
  if (waveCenter) {
    const waveRadius = random(150, 250);

    // üöÄ Optimisation: utilise cache de longueur au lieu de forEach
    for (let i = 0; i < particlesCount; i++) {
      const particle = particles[i];
      const distance = dist(particle.x, particle.y, waveCenter.x, waveCenter.y);
      if (distance < waveRadius) {
        const intensity = map(distance, 0, waveRadius, 1, 0.3);
        particle.blurSpeed = random(0.08, 0.2) * intensity;
        particle.maxBlur = random(20, 50) * intensity;
        particle.blurPhase = random(TWO_PI);
      }
    }
  }
}

function addParticles(count) {
  let added = 0;
  let attempts = 0;
  let maxAttempts = count * 10;

  while (added < count && attempts < maxAttempts && validPixelsCount > 0) {
    attempts++;
    let randomPixel = getRandomPixel(); // üöÄ Utilise pool optimis√©

    if (randomPixel) {
      let newParticle = new Particle(randomPixel.x, randomPixel.y);
      particles.push(newParticle);
      newParticle.shine();
      added++;
      depthSortNeeded = true; // üöÄ Marquer tri n√©cessaire
    }
  }

  // üöÄ Mise √† jour cache apr√®s ajout
  particlesCount = particles.length;

  // Ajouter zones proportionnelles (utilise pool optimis√©)
  const newZones = Math.floor(added / 20);
  for (let i = 0; i < newZones && hotZonesCount < 8; i++) {
    let randomPixel = getRandomPixel(); // üöÄ Pool optimis√©
    if (randomPixel) {
      hotZones.push(new SimpleHotZone(randomPixel.x, randomPixel.y));
      hotZonesCount++; // üöÄ Mise √† jour cache
    }
  }

  if (added > 0) triggerBlurWave();
}

function removeParticles(count) {
  let toRemove = min(count, particlesCount); // üöÄ Utilise cache
  let indicesToRemove = [];

  let availableIndices = Array.from({ length: particlesCount }, (_, i) => i); // üöÄ Cache
  for (let i = 0; i < toRemove; i++) {
    let randomIndex = floor(random(availableIndices.length));
    indicesToRemove.push(availableIndices[randomIndex]);
    availableIndices.splice(randomIndex, 1);
  }

  indicesToRemove.forEach((index) => {
    if (particles[index]) particles[index].shine();
  });

  setTimeout(() => {
    indicesToRemove.sort((a, b) => b - a);
    indicesToRemove.forEach((index) => particles.splice(index, 1));

    // üöÄ Mise √† jour cache apr√®s suppression
    particlesCount = particles.length;
    depthSortNeeded = true; // Tri n√©cessaire apr√®s suppression

    const zonesToRemove = Math.floor(toRemove / 30);
    for (let i = 0; i < zonesToRemove && hotZonesCount > 1; i++) {
      hotZones.pop();
      hotZonesCount--; // üöÄ Mise √† jour cache
    }
  }, 100);
}

function resetParticles() {
  particles.forEach((particle) => particle.shine());

  setTimeout(() => {
    particles = [];
    hotZones = [];

    for (let i = 0; i < NUM_PARTICLES; i++) {
      let randomPixel = getRandomPixel(); // üöÄ Pool optimis√©
      if (randomPixel) {
        particles.push(new Particle(randomPixel.x, randomPixel.y));
      }
    }

    const initialZones = Math.floor(NUM_PARTICLES / 50);
    for (let i = 0; i < Math.min(initialZones, 3); i++) {
      let randomPixel = getRandomPixel(); // üöÄ Pool optimis√©
      if (randomPixel) {
        hotZones.push(new SimpleHotZone(randomPixel.x, randomPixel.y));
      }
    }

    // üöÄ Mise √† jour cache apr√®s reset
    particlesCount = particles.length;
    hotZonesCount = hotZones.length;
    depthSortNeeded = true;
    generateRandomPools(); // R√©g√©n√©rer pools

    triggerBlurWave();
  }, 200);
}

function clearAllParticles() {
  particles.forEach((particle) => particle.shine());

  for (let i = 0; i < 3; i++) {
    setTimeout(() => triggerBlurWave(), i * 100);
  }

  setTimeout(() => {
    particles = [];
    hotZones = [];

    // üöÄ Mise √† jour cache apr√®s clear
    particlesCount = 0;
    hotZonesCount = 0;
    generateRandomPools(); // R√©g√©n√©rer pools vides
  }, 400);
}

// === √âV√âNEMENTS ===
function windowResized() {
  if (canvasContainer) {
    resizeCanvas(canvasContainer.width, canvasContainer.height);
  }
}

// === SYST√àME AUDIO SOPHISTIQU√â (V1) ===
function initAudio() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    gainNode.connect(audioContext.destination);
  } catch (e) {
    console.error(e);
  }
}

function updateAudio(activityLevel) {
  if (!audioEnabled || !audioContext) return;

  const now = audioContext.currentTime;

  // Pure electrical discharge sounds based on activity
  if (activityLevel > 0) {
    // Electrical sparks - short, sharp, random
    if (Math.random() < activityLevel / 150) {
      createElectricalSpark(now);
    }

    // Crackling static during activity
    if (Math.random() < activityLevel / 200) {
      createStaticCrackle(now);
    }
  }

  // Subtle electrical hum (very quiet background)
  if (Math.random() < 0.1) {
    createElectricalHum(now, activityLevel);
  }
}

function createElectricalSpark(startTime) {
  if (!audioContext || !gainNode) return;

  const duration = 0.01 + Math.random() * 0.02;
  const bufferSize = Math.floor(audioContext.sampleRate * duration);
  const buffer = audioContext.createBuffer(
    1,
    bufferSize,
    audioContext.sampleRate
  );
  const data = buffer.getChannelData(0);

  // Generate electrical noise - sharp, crackling
  for (let i = 0; i < bufferSize; i++) {
    const spike = Math.random() < 0.1 ? (Math.random() - 0.5) * 4 : 0;
    const base = (Math.random() - 0.5) * 0.3;
    data[i] = spike + base;
    if (i > 0) {
      data[i] += data[i - 1] * 0.1;
    }
  }

  const source = audioContext.createBufferSource();
  const gain = audioContext.createGain();
  const filter = audioContext.createBiquadFilter();

  source.buffer = buffer;
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.setTargetAtTime(0.4, startTime, 0.001);
  gain.gain.setTargetAtTime(0, startTime + duration * 0.3, 0.005);

  filter.type = "highpass";
  filter.frequency.setValueAtTime(1000 + Math.random() * 2000, startTime);
  filter.Q.setValueAtTime(0.5, startTime);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(gainNode);
  source.start(startTime);
}

function createStaticCrackle(startTime) {
  if (!audioContext || !gainNode) return;

  const duration = 0.05 + Math.random() * 0.1;
  const bufferSize = Math.floor(audioContext.sampleRate * duration);
  const buffer = audioContext.createBuffer(
    1,
    bufferSize,
    audioContext.sampleRate
  );
  const data = buffer.getChannelData(0);

  let energy = 1.0;
  for (let i = 0; i < bufferSize; i++) {
    energy *= 0.9999;
    const pop = Math.random() < 0.02 ? (Math.random() - 0.5) * 2 : 0;
    const crackle = (Math.random() - 0.5) * energy * 0.5;
    data[i] = pop + crackle;
    if (i > 2) {
      data[i] += (data[i - 1] - data[i - 2]) * 0.2;
    }
  }

  const source = audioContext.createBufferSource();
  const gain = audioContext.createGain();
  const filter = audioContext.createBiquadFilter();

  source.buffer = buffer;
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.setTargetAtTime(0.2, startTime, 0.01);
  gain.gain.setTargetAtTime(0, startTime + duration * 0.7, 0.02);

  filter.type = "bandpass";
  filter.frequency.setValueAtTime(800 + Math.random() * 1500, startTime);
  filter.Q.setValueAtTime(2, startTime);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(gainNode);
  source.start(startTime);
}

function createElectricalHum(startTime, activityLevel = 0) {
  if (!audioContext || !gainNode) return;

  const duration = 0.3 + Math.random() * 0.2;
  const bufferSize = Math.floor(audioContext.sampleRate * duration);
  const buffer = audioContext.createBuffer(
    1,
    bufferSize,
    audioContext.sampleRate
  );
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    const t = i / audioContext.sampleRate;
    const fundamental = Math.sin(2 * Math.PI * 50 * t) * 0.1;
    const harmonic = Math.sin(2 * Math.PI * 100 * t) * 0.05;
    const noise = (Math.random() - 0.5) * 0.02;
    data[i] = fundamental + harmonic + noise;
  }

  const source = audioContext.createBufferSource();
  const gain = audioContext.createGain();
  const filter = audioContext.createBiquadFilter();

  source.buffer = buffer;
  const volume = 0.03 + activityLevel * 0.0001;
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.setTargetAtTime(volume, startTime, 0.1);
  gain.gain.setTargetAtTime(0, startTime + duration * 0.8, 0.1);

  filter.type = "lowpass";
  filter.frequency.setValueAtTime(200, startTime);
  filter.Q.setValueAtTime(0.5, startTime);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(gainNode);
  source.start(startTime);
}

function startAudio() {
  if (!audioContext || !gainNode) return;

  if (audioContext.state === "suspended") {
    audioContext.resume();
  }
  gainNode.gain.setTargetAtTime(0.1, audioContext.currentTime, 0.1);
}

function stopAudio() {
  if (!audioContext || !gainNode) return;

  gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
  setTimeout(() => {
    if (audioContext && audioContext.state === "running") {
      audioContext.suspend();
    }
  }, 200);
}

function mousePressed() {
  audioEnabled = !audioEnabled;

  if (audioEnabled) {
    startAudio();
  } else {
    stopAudio();
  }
}

function keyPressed() {
  if (key === "+" || key === "=") {
    addParticles(50);
  } else if (key === "-" || key === "_") {
    removeParticles(50);
  } else if (key.toLowerCase() === "r") {
    resetParticles();
  } else if (key.toLowerCase() === "c") {
    clearAllParticles();
  } else if (key.toLowerCase() === "b") {
    triggerBlurWave();
  }
}
